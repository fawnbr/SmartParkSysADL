Model SmartPark ; Requirement GerenciarEstacionamento ( 1 ) { text = "\"O sistema deve gerir todos os recursos utilizados pelo estacionamento.\"" Requirement GerenciarUsuarios ( 1.1 ) { text = "\"O sistema deve ser capaz de gerenciar usuários do sistema.\"" } Requirement GerenciarEntradaESaida ( 1.2 ) { text = "\"O sistema deve controlar o acesso de entrada e saída a partir da leitura da placa do veículo.\"" satisfied by Componentes.ControladorDeCameraCP ; } Requirement GerenciarPagamento ( 1.3 ) { text = "\"O sistema deve fornecer mecanismos de precificar a permanência no estacionamento e mecanismos para efetuar o pagamento.\"" satisfied by Componentes.ControladorDePagamentosCP ; } Requirement GerenciarVagasLivres ( 1.4 ) { text = "\"O sistema deve conseguir gerenciar as vagas livres e ocupadas.\"" } } Requirement GerenciarFuncionarios ( 1.1.1 ) { text = "\"O sistema deve gerenciar funcionários e controlar acesso a partir de seus respectivos perfis.\"" satisfied by Componentes.ControladorCentralCP ; derive GerenciarEstacionamento.GerenciarUsuarios ; } Requirement GerenciarMotoristas ( 1.1.2 ) { text = "\"O sistema deve gerenciar motoristas e controlar acesso a partir de seus respectivos perfis.\"" satisfied by Componentes.ControladorCentralCP ; derive GerenciarEstacionamento.GerenciarUsuarios ; } Requirement LiberarEntrada ( 1.2.1 ) { text = "\"O sistema deve abrir a cancela automaticamente após leitura da placa do veículo.\"" satisfied by Componentes.CancelaCP , Componentes.CameraCP , Componentes.IdentificadorDePlacaCP ; derive GerenciarEstacionamento.GerenciarEntradaESaida ; } Requirement LiberarSaida ( 1.2.2 ) { text = "\"O sistema deve abrir a cancela automaticamente após ler a placa do veículo e confirmar pagamento.\"" satisfied by Componentes.CancelaCP , Componentes.CameraCP , Componentes.IdentificadorDePlacaCP ; derive GerenciarEstacionamento.GerenciarEntradaESaida ; } Requirement EfetuarPagamento ( 1.3.1 ) { text = "\"O sistema deve fornecer mecanismos para efetuar o pagamento.\"" satisfied by Componentes.FonteDePagamentoCP ; derive GerenciarEstacionamento.GerenciarPagamento ; } Requirement PrecificarPermanencia ( 1.3.2 ) { text = "\"O sistema deve permitir precificar a permanência no estacionamento.\"" satisfied by Componentes.ControladorDePermanenciaCP ; derive GerenciarEstacionamento.GerenciarPagamento ; } Requirement Escalabilidade ( 2 ) { text = "\"O sistema deve possuir flexibilidade para ser possível escalar o sistema.\"" } Requirement Disponibilidade ( 3 ) { text = "\"O sistema deve permitir múltiplos meios de realizar uma mesma atividade para manter-se disponível.\"" } package Componentes { import Conectores ; import Portas ; import Tipos ; boundary
	component def CancelaCP { ports : comandoEntrada : CancelaIPT ; } boundary
	component def CameraCP { ports : foto : CameraOPT ; datatype newElement { } } boundary
	component def FonteDePagamentoCP { ports : pagamentoSaida : PagamentoOPT ; precoASerPago : PrecoIPT ; datatype newElement { } } boundary
	component def SensorDePresencaCP { ports :  valorSensor : SensorPresencaOPT ; } boundary
	component def DisplayLedCP { ports : vagasDisponiveis : VagasIPT ; } component def SistemaCentralCP {  configuration { components :           cam : CameraCP [ 1 , 10 ] { using ports : foto : CameraOPT ; }  CancelaCP : CancelaCP [ 1 , 10 ] { using ports : comandoEntrada : CancelaIPT ; }  ip : IdentificadorDePlacaCP { using ports : fotoEntrada : CameraIPT ; placaSaida : PlacaOPT ; } ccam : ControladorDeCameraCP { using ports : fotoEntradaControlador : CameraIPT ; solicitacaoDeFluxo : SolicitacaoDeFluxoOPT ; fotoSaidaControlador : CameraOPT ; placaEntrada : PlacaIPT ; } cper : ControladorDePermanenciaCP { using ports : permanenciaEntrada : PermanenciaIPT [ 1 , 2 ] ; precoSaida : PrecoOPT ; } cpag : ControladorDePagamentosCP [ 1 , 2 ] { using ports : veiculoConsultado : IdentificadorIPT ; veiculoLiberadoSaida : LiberacaoOPT ; pagamentoEntrada : PagamentoIPT ; fimPermanenciaSaida : PermanenciaOPT ; precoAPagar : PrecoIPT ; precoParaTerminalDePagamento : PrecoOPT ; } fp : FonteDePagamentoCP { using ports : pagamentoSaida : PagamentoOPT ; precoASerPago : PrecoIPT ; } gv : GerenciadorDeVagasCP { using ports : capacidadeDoEstacionamento : VagasIPT ; valorSensores : SensorPresencaIPT ; vagasAtuaisDisponiveis : VagasOPT ; } sp : SensorDePresencaCP [ 1 , 10 ] { using ports : valorSensor : SensorPresencaOPT ; } led : DisplayLedCP [ 1 , 10 ] { using ports : vagasDisponiveis : VagasIPT ; }  SmartParkICP : SmartParkICP [ 1 , 10 ] { using ports : comandoManualSaida : CancelaOPT ; solicitacaoDeFluxoManual : SolicitacaoDeFluxoOPT ; veiculoLiberadoManual : LiberacaoIPT ; } cc : ControladorCentralCP [ 1 , 2 ] { using ports : entradaDeSolicitacaoDeFluxo : SolicitacaoDeFluxoIPT ; comandoSaida : CancelaOPT ; inicioPermanenciaSaida : PermanenciaOPT ; veiculoComPagamentoAValidar : IdentificadorOPT ; veiculoLiberadoEntrada : LiberacaoIPT ; vagasDoEstacionamento : VagasOPT ; liberacaoManualSaida : LiberacaoOPT ; } connectors : fotoVeiculo : CameraCN bindings foto = fotoEntradaControlador ; fotoAIdentificar : CameraCN bindings fotoSaidaControlador = fotoEntrada ; placaIdentificada : PlacaCN bindings placaSaida = placaEntrada ;    atividadeDosSensores : PresencaCN bindings valorSensor = valorSensores ; numeroDeVagas : VagasCN bindings vagasAtuaisDisponiveis = vagasDisponiveis ;   precoPendenteDePagamento : PrecoCN bindings precoParaTerminalDePagamento = precoASerPago ; solicitacaoPagamento : PagamentoCN bindings pagamentoSaida = pagamentoEntrada ;  fimPermanencia : PermanenciaCN bindings fimPermanenciaSaida = permanenciaEntrada ; preco : PrecoCN bindings precoSaida = precoAPagar ; comandoManualCancela : CancelaCN bindings comandoManualSaida = comandoEntrada ; solicitacaoDeEntradaOuSaida : SolicitacaoDeFluxoCN bindings solicitacaoDeFluxo = entradaDeSolicitacaoDeFluxo ; veiculoAConsultar : IdentificadorCN bindings veiculoComPagamentoAValidar = veiculoConsultado ; liberado : LiberacaoCN bindings veiculoLiberadoSaida = veiculoLiberadoEntrada ; quantidadeDeVagas : VagasCN bindings vagasDoEstacionamento = capacidadeDoEstacionamento ; controleDeFluxoManual : SolicitacaoDeFluxoCN bindings solicitacaoDeFluxoManual = entradaDeSolicitacaoDeFluxo ; liberacaoManual : LiberacaoCN bindings liberacaoManualSaida = veiculoLiberadoManual ; inicioPermanencia : PermanenciaCN bindings inicioPermanenciaSaida = permanenciaEntrada ; comandoCancela : CancelaCN bindings comandoSaida = comandoEntrada ; } }
	component def ControladorDePagamentosCP { ports : identificadorConsultado : IdentificadorIPT ; veiculoLiberadoSaida : LiberacaoOPT ; pagamentoEntrada : PagamentoIPT ; fimPermanenciaSaida : PermanenciaOPT ; precoAPagar : PrecoIPT ; precoParaTerminalDePagamento : PrecoOPT ; }
	component def GerenciadorDeVagasCP { ports :  capacidadeDoEstacionamento : VagasIPT ; valorSensores : SensorPresencaIPT [ 1 , 10 ] ; vagasAtuaisDisponiveis : VagasOPT ; }
	component def IdentificadorDePlacaCP { ports : fotoEntrada : CameraIPT ; placaSaida : PlacaOPT ; }
	component def ControladorCentralCP { ports : acessoEntrada : SolicitacaoDeFluxoIPT [ 1 , 2 ] ; comandoSaida : CancelaOPT ; inicioPermanenciaSaida : PermanenciaOPT ; validarPagamentoVeiculo : IdentificadorOPT ; veiculoLiberadoEntrada : LiberacaoIPT ; vagasDoEstacionamento : VagasOPT ; liberacaoManualSaida : LiberacaoOPT ; }
	component def ControladorDeCameraCP { ports : fotoEntradaControlador : CameraIPT ; acessoSaida : SolicitacaoDeFluxoOPT ; fotoSaidaControlador : CameraOPT ; placaEntrada : PlacaIPT ; }
	component def ControladorDePermanenciaCP { ports : permanenciaEntrada : PermanenciaIPT [ 1 , 2 ] ; precoSaida : PrecoOPT ; } component def SmartParkICP { ports : comandoManualSaida : CancelaOPT ; acessoManual : SolicitacaoDeFluxoOPT ; veiculoLiberadoManual : LiberacaoIPT ; }  action def CalculaVagasDisponiveisAN ( capacidadeVagas : Integer , vagasOcupadas : Integer ) : Integer { constraint : post-condition CalculaVagasLivresEQ delegate vagasOcupadas to vagasOcupadas delegate capacidadeVagas to capacidadeVagas delegate CalculaVagasDisponiveisAN to vagasDisponiveis } 
	constraint CalculaVagasLivresEQ ( capacidadeVagas : Integer , vagasOcupadas : Integer ) : ( vagasDisponiveis : Integer ) {
		equation = (capacidadeVagas - vagasOcupadas)
	} activity def ControladorDeCameraAC ( fotoPlacaIn : String ) ( placaIdentificadaIn : String ) : ( fotoPlacaOut : String , placaIdentificadaOut : SolicitacaoDeFluxo ) { body { actions : enviaSolicitacaoDeEntradaOuSaidaAN : EnviaSolicitacaoDeEntradaOuSaidaAN { using pins : placa : SolicitacaoDeFluxo ; } redirecionaFotoAN : RedirecionaFotoAN { using pins : foto : String ; } delegate placaIdentificadaOut to enviaSolicitacaoDeEntradaOuSaidaAN delegate fotoPlacaOut to redirecionaFotoAN delegate placaIdentificadaIn to placa delegate fotoPlacaIn to foto } } action def EnviaSolicitacaoDeEntradaOuSaidaAN ( placa : SolicitacaoDeFluxo ) : SolicitacaoDeFluxo { } action def RedirecionaFotoAN ( foto : String ) : String { }     action def ProcessaVagasOcupadasAN ( sensorDePresenca : Boolean , vagasOcupadasAtual : Integer ) : Integer { constraint : post-condition ProcessaMudancaSensorEQ delegate vagasOcupadasAtual to vagasOcupadasInicial delegate sensorDePresenca to sensorDePresenca delegate ProcessaVagasOcupadasAN to vagasOcupadasFinal } activity def GerenciadorDeVagasAC ( capacidadeVagas : Integer ) ( vagasOcupadas : Integer ) ( sensorDePresenca : Boolean ) : ( vagasLivres : flow Integer ) { body { actions : ProcessaVagasOcupadasAN : ProcessaVagasOcupadasAN { using pins : sensorDePresenca : Boolean ; vagasOcupadas : Integer ; } CalculaVagasDisponiveisAN : CalculaVagasDisponiveisAN { using pins : capacidadeVagas : Integer ; vagasOcupadasAtual : Integer ; } delegate sensorDePresenca to sensorDePresenca delegate vagasOcupadas to vagasOcupadas flow from ProcessaVagasOcupadasAN to vagasOcupadasAtual delegate capacidadeVagas to capacidadeVagas delegate vagasLivres to CalculaVagasDisponiveisAN } } 
	constraint ProcessaMudancaSensorEQ ( sensorDePresenca : Boolean , vagasOcupadasInicial : Integer ) : ( vagasOcupadasFinal : Integer ) { 
		equation = (sensorDePresenca == true) ? (vagasOcupadasInicial++) : (vagasOcupadasInicial--)	
	} 
	action def LiberarEntradaOuSaidaAN ( liberado : Boolean ) : Comandos { constraint : post-condition ComandarCancelaEQ } action def VerificarEstacionamentoPagoAN ( identificador : String ) : String { } action def ProcessarSolicitacaoDeEntradaOuSaidaAN ( acesso : SolicitacaoDeFluxo ) : Boolean { } activity def ControladorCentralAC ( novoAcesso : SolicitacaoDeFluxo ) ( estacionamentoPago : ConfirmacaoDePagamento ) : ( comandoCancela : Comandos , placaAVerificar : String , iniciarPermanencia : Permanencia , vagasTotais : Integer ) { body { actions : ProcessarEntradaOuSaidaAN : ProcessarSolicitacaoDeEntradaOuSaidaAN { using pins : fluxo : SolicitacaoDeFluxo ; } VerificarEstacionamentoPago : VerificarEstacionamentoPagoAN { using pins : identificador : SolicitacaoDeFluxo ; } LiberarAcessoAN : LiberarEntradaOuSaidaAN { using pins : liberado : Boolean ; } ExtrairIdentificadorDeAcesso : ExtrairIdentificadorDeAcessoAN { using pins : acessoVeiculo : SolicitacaoDeFluxo ; } IniciarPermanenciaAN : IniciarPermanenciaAN { using pins : entradaNovoVeiculo : String ; } DefinirQuantidadeDeVagasTotaisAN : DefinirQuantidadeDeVagasTotaisAN { using pins : vagasTotais : Integer ; } ExtrairPagoDeConfirmacaoDePagamentoAN : ExtrairPagoDeConfirmacaoDePagamentoAN { using pins : confirmacao : ConfirmacaoDePagamento ; } delegate novoAcesso to fluxo    delegate comandoCancela to LiberarAcessoAN delegate placaAVerificar to VerificarEstacionamentoPago  flow from  ProcessarEntradaOuSaidaAN to liberado  delegate novoAcesso to acessoVeiculo flow from ExtrairIdentificadorDeAcesso to identificador flow from ExtrairIdentificadorDeAcesso to entradaNovoVeiculo delegate iniciarPermanencia to IniciarPermanenciaAN delegate vagasTotais to DefinirQuantidadeDeVagasTotaisAN flow from quantidadeDeVagasTotais to vagasTotais delegate estacionamentoPago to confirmacao flow from ExtrairPagoDeConfirmacaoDePagamentoAN to liberado datastore quantidadeDeVagasTotais : Integer } } 
	constraint ComandarCancelaEQ ( liberar : Boolean ) : ( comandoParaCancela : Comandos ) { 
		equation = (liberar == true) ? (comandoParaCancela->cancela == ComandoCancela::Abrir) : (comandoParaCancela->cancela == ComandoCancela::Fechar)
	} activity def IdentificadorDePlacasAC ( fotoCamera : String ) : ( placaProcessada : String ) { body { actions : IdentificarPlacaAN : IdentificarPlacaAN { using pins : foto : String ; } delegate fotoCamera to foto delegate placaProcessada to IdentificarPlacaAN } } action def IdentificarPlacaAN ( foto : String ) : String { } action def IniciarPermanenciaAN ( entradaNovoVeiculo : String ) : Permanencia { } action def ExtrairIdentificadorDeAcessoAN ( acessoVeiculo : SolicitacaoDeFluxo ) : String { } action def DefinirQuantidadeDeVagasTotaisAN ( vagasTotais : Integer ) : Integer { } action def EntradaPermanenciaAN ( inicioPermanencia : Permanencia ) : Permanencia { } action def ConcluirPermanenciaAN ( fimPermanencia : Permanencia ) : Permanencia { } action def PrecificarEstadiaAN ( inicio : Permanencia , fim : Permanencia ) : Double { } activity def ControladorDePermanenciaAC ( novaPermanencia : Permanencia ) : ( precoAPagar : Double ) { body { actions :  ConcluirPermanenciaAN : ConcluirPermanenciaAN { using pins : fimPermanencia : Permanencia ; } PrecificarEstadiaAN : PrecificarEstadiaAN { using pins : inicio : Permanencia ; fim : Permanencia ; } EntradaPermanenciaAN : EntradaPermanenciaAN { using pins : inicioPermanencia : Permanencia ; } flow from ConcluirPermanenciaAN to permanenciaBD delegate novaPermanencia to fimPermanencia delegate precoAPagar to PrecificarEstadiaAN flow from permanenciaBD to inicio flow from permanenciaBD to fim delegate novaPermanencia to inicioPermanencia flow from EntradaPermanenciaAN to permanenciaBD datastore permanenciaBD : Permanencia } } activity def ControladorDePagamentosAC ( solicitacaoPagamento : Pagamento ) ( identificadorDoVeiculo : String ) : ( finalizacaoPermanencia : Permanencia , precoAPagar : Double , pagamentoEfetuado : ConfirmacaoDePagamento ) { body { actions : VerificarPagamentoEfetuadoAN : VerificarPagamentoEfetuadoAN { using pins : identificador : String ; } EnviarFinalizacaoDePermanenciaAN : EnviarFinalizacaoDePermanenciaAN { using pins : pagamento : Pagamento ; } EnviarCustoDePermanenciaAN : EnviarCustoDePermanenciaAN { using pins : novoPagamento : Pagamento ; } delegate identificadorDoVeiculo to identificador delegate pagamentoEfetuado to VerificarPagamentoEfetuadoAN delegate solicitacaoPagamento to pagamento delegate finalizacaoPermanencia to EnviarFinalizacaoDePermanenciaAN delegate solicitacaoPagamento to novoPagamento delegate precoAPagar to EnviarCustoDePermanenciaAN } } action def EnviarFinalizacaoDePermanenciaAN ( pagamento : Pagamento ) : Permanencia { } action def EnviarCustoDePermanenciaAN ( novoPagamento : Pagamento ) : Double { } action def VerificarPagamentoEfetuadoAN ( identificador : String ) : ConfirmacaoDePagamento { } action def ExtrairPagoDeConfirmacaoDePagamentoAN ( confirmacao : ConfirmacaoDePagamento ) : Boolean { } } package Portas { import Tipos ;   port def CameraOPT { flow out String }  port def CancelaIPT { flow in Comandos } port def CameraIPT { flow in String } port def SolicitacaoDeFluxoOPT { flow out SolicitacaoDeFluxo } port def PlacaOPT { flow out String } port def SolicitacaoDeFluxoIPT { flow in SolicitacaoDeFluxo } port def CancelaOPT { flow in Comandos } port def PermanenciaIPT { flow in Permanencia } port def PermanenciaOPT { flow out Permanencia } port def PlacaIPT { flow in String } port def LiberacaoOPT { flow out ConfirmacaoDePagamento } port def LiberacaoIPT { flow in ConfirmacaoDePagamento } port def PagamentoIPT { flow in Pagamento } port def PagamentoOPT { flow out Pagamento } port def PrecoIPT { flow in Double } port def PrecoOPT { flow out Double } port def VagasIPT { flow in Integer } port def VagasOPT { flow out Integer } port def SensorPresencaIPT { flow in Boolean } port def SensorPresencaOPT { flow out Boolean } port def IdentificadorIPT { flow in String } port def IdentificadorOPT { flow out String } } package Conectores { import Portas ;  connector def CameraCN { participants : ~ fotoSaida : CameraOPT ; ~ fotoEntrada : CameraIPT ; flows : String from fotoSaida to fotoEntrada } connector def SolicitacaoDeFluxoCN { participants : ~ solicitacaoDeFluxoSaida : SolicitacaoDeFluxoOPT ; ~ solicitacaoDeFluxoEntrada : SolicitacaoDeFluxoIPT ; flows : SolicitacaoDeFluxo from solicitacaoDeFluxoSaida to solicitacaoDeFluxoEntrada } connector def PlacaCN { participants : ~ placaSaida : PlacaOPT ; ~ placaEntrada : PlacaIPT ; flows : String from placaSaida to placaEntrada } connector def PagamentoCN { participants : ~ pagamentoSaida : PagamentoOPT ; ~ pagamentoEntrada : PagamentoIPT ; flows : Pagamento from pagamentoSaida to pagamentoEntrada } connector def LiberacaoCN { participants : ~ liberacaoSaida : LiberacaoOPT ; ~ liberacaoEntrada : LiberacaoIPT ; flows : ConfirmacaoDePagamento from liberacaoSaida to liberacaoEntrada } connector def PermanenciaCN { participants : ~ permanenciaSaida : PermanenciaOPT ; ~ permanenciaEntrada : PermanenciaIPT ; flows : Permanencia from permanenciaSaida to permanenciaEntrada } connector def CancelaCN { participants : ~ comandoCancelaSaida : CancelaOPT ; ~ comandoCancelaEntrada : CancelaIPT ; flows : Comandos from comandoCancelaSaida to comandoCancelaEntrada } connector def PrecoCN { participants : ~ precoSaida : PrecoOPT ; ~ precoEntrada : PrecoIPT ; flows : Double from precoSaida to precoEntrada } connector def VagasCN { participants : ~ vagasTotaisSaida : VagasOPT ; ~ vagasTotaisEntrada : VagasIPT ; flows : Integer from vagasTotaisSaida to vagasTotaisEntrada } connector def PresencaCN { participants : ~ sensorSaida : SensorPresencaOPT ; ~ sensorEntrada : SensorPresencaIPT ; flows : Boolean from sensorSaida to sensorEntrada } connector def IdentificadorCN { participants : ~ identificadorSaida : IdentificadorOPT ; ~ identificadorEntrada : IdentificadorIPT ; flows : String from identificadorSaida to identificadorEntrada } } package Tipos {   value type String { } value type Boolean { } value type Integer { } datatype Comandos { attributes : cancela : ComandoCancela ; } enum ComandoCancela { Abrir , Fechar } datatype SolicitacaoDeFluxo { attributes : identificador : String ; entrada : Boolean ; } datatype Permanencia { attributes : identificador : String ; inicio : Boolean ; } datatype Pagamento { attributes : identificador : String ; opcaoPagamento : Integer ; } value type Double { } datatype ConfirmacaoDePagamento { attributes : identificador : String ; pago : Boolean ; } } Requirement VisualizarVagasLivres ( 1.4.1 ) { text = "\"O sistema deve possuir mecanismos de visualizar as vagas livres.\"" satisfied by Componentes.DisplayLedCP ; derive GerenciarEstacionamento.GerenciarVagasLivres ; } Requirement PerceberOcupacaoVagas ( 1.4.2 ) { text = "\"O sistema deve possuir sensores que percebam se uma vaga está ocupada ou não.\"" satisfied by Componentes.SensorDePresencaCP ; derive GerenciarEstacionamento.GerenciarVagasLivres ; }